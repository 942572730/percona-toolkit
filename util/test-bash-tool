#!/usr/bin/env bash

die() {
   echo $1 >&2
   exit 255
}

warn() {
   echo $1 >&2
}

if [ -n "$PERCONA_TOOLKIT_BRANCH" ]; then
   BRANCH=$PERCONA_TOOLKIT_BRANCH
   cd $BRANCH
else
   while [ ! -f Makefile.PL ] && [ $(pwd) != "/" ]; do
      cd ..
   done
   if [ ! -f Makefile.PL ]; then
      die "Cannot find the root directory of the Percona Toolkit branch"
      exit 1
   fi
   BRANCH=`pwd`
fi

result() {
   result=$1
   if [ $result -eq 0 ]; then
      echo -n "ok $testno - $t"
   else
      echo "not ok $testno - $t"
      failed_tests=$(( failed_tests + 1))
      # Indent and display the first 30 lines
      diff "${GL_result}" "${GL_expected}" | sed -e 's/^/#   /' -e '30q'
   fi

   testno=$(( testno + 1))
}

# All variables are named GL_whatever so they don't get overwritten with stuff
# that happens in the functions sourced.
GL_input="/tmp/percona-toolkit-test"
GL_expected="/tmp/percona-toolkit-test-expected"
GL_result="/tmp/percona-toolkit-test-result"

run_test() {
   t=$1  # test file name, e.g. "group-by-all-01" for pt-diskstats

   # Return unless the test file is bash.  There may be other types of
   # files in the tool's test dir.
   head -n 1 $t | grep -q bash || die "$t is not a bash file"

   # The format of the test file is as follows:
   # - line 1 is the shebang
   # - line 2 is the command to run, commented out
   # - argument 1 is the file to which the expected result should be printed
   # - argument 2 is the file to which the input should be printed

   # Get the command to run
   GL_cmd="$(head -n2 $t | tail -n1 | cut -b2-)"

   # Execute the file and tell it where to save the input & expected result
   if [ -x "${t}" ]; then
      ./$t "${GL_expected}" "${GL_input}"
   else
      die "$t is not executable"
   fi

   # Execute the command
   ${GL_cmd} > "${GL_result}"

   # Is the result the same as the expected result?
   diff -q "${GL_result}" "${GL_expected}" >/dev/null
   result $?

   # Clean up
   rm -f /tmp/percona-toolkit-test*
}

tool=$1  # bash tool, e.g. pt-diskstats
t=$2     # optional test file, e.g. group-by-all-01
if [ -z "$tool" ]; then
   die "No tool specified"
fi

cd $BRANCH/bin
if [ ! -f $tool ]; then
   die "$tool does not exist"
fi
head -n1 $tool | grep bash || die "$tool is not a bash file"

# Source the tool, i.e. import its functions.
source $tool

cd $BRANCH/t/$tool
testno=1
failed_tests=0
if [ -z "$t" ]; then
   # Run all the tool's tests.
   for t in *; do
      run_test $t
   done
else
   # Run just the specified test.
   run_test $t
fi

exit $failed_tests
